1、彩色的搬砖
小易有一些彩色的砖块。每种颜色由一个大写字母表示。各个颜色砖块看起来都完全一样。现在有一个给定的字符串s,s中每个字符代表小易的某个砖块的颜色。
小易想把他所有的砖块排成一行。如果最多存在一对不同颜色的相邻砖块,那么这行砖块就很漂亮的。请你帮助小易计算有多少种方式将他所有砖块排成漂亮的一
行。(如果两种方式所对应的砖块颜色序列是相同的,那么认为这两种方式是一样的。)
例如: s = "ABAB",那么小易有六种排列的结果:
"AABB","ABAB","ABBA","BAAB","BABA","BBAA"
其中只有"AABB"和"BBAA"满足最多只有一对不同颜色的相邻砖块。

输入描述:
输入包括一个字符串s,字符串s的长度length(1 ≤ length ≤ 50),s中的每一个字符都为一个大写字母(A到Z)。
输出描述:
输出一个整数,表示小易可以有多少种方式。

输入
ABAB
输出
2


#include <bits/stdc++.h>
using namespace std;

int main()
{
    string data;
    getline(cin,data);
    map<char,int> result;
    for(int i=0;i<data.size();++i)
    {
        if(result.find(data[i])!=result.end())
        {
            result[data[i]]++;
        }
        else
        {
            result[data[i]]=1;
        }
    }

    if(result.size()==1)
    {
        cout<<1<<endl;
    }
    else if(result.size()==2)
    {
        cout<<2<<endl;
    }
    else
    {
        cout<<0<<endl;
    }

    return 0;

}


2、等差数列
如果一个数列S满足对于所有的合法的i,都有S[i + 1] = S[i] + d, 这里的d也可以是负数和零,我们就称数列S为等差数列。
小易现在有一个长度为n的数列x,小易想把x变为一个等差数列。小易允许在数列上做交换任意两个位置的数值的操作,并且交换操作允许交换多次。
但是有些数列通过交换还是不能变成等差数列,小易需要判别一个数列是否能通过交换操作变成等差数列

输入描述:
输入包括两行,第一行包含整数n(2 ≤ n ≤ 50),即数列的长度。
第二行n个元素x[i](0 ≤ x[i] ≤ 1000),即数列中的每个整数。
输出描述:
如果可以变成等差数列输出"Possible",否则输出"Impossible"。

输入
3
3 1 2
输出
Possible

#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n;
    vector<int> data;
    for(int i=0;i<n;++i)
    {
        int temp;
        cin>>temp;
        data.push_back(temp);
    }
    sort(data.begin(),data.end());

    bool flag=true;
    int d=data[1]-data[0];
    for(int i=2;i<data.size();++i)
    {
        if(d!=data[i]-data[i-1])
        {
            flag=false;
            break;
        }
    }
    if(flag)
    {
        cout<<"Possible"<<endl;
    }
    else
    {
        cout<<"Impossible"<<endl;
    }
    return 0;

}

