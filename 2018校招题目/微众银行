1、单词缩写
在日常书面表达中，我们经常会碰到很长的单词，比如"localization"、"internationalization"等。为了书写方便，我们会将太长的单词进行缩写。
这里进行如下定义：
如果一个单词包含的字符个数超过10则我们认为它是一个长单词。所有的长单词都需要进行缩写，缩写的方法是先写下这个单词的首尾字符，然后再在首
尾字符中间写上这个单词去掉首尾字符后所包含的字符个数。比如"localization"缩写后得到的是"l10n"，"internationalization"缩写后得到的是
"i18n"。现给出n个单词，将其中的长单词进行缩写，其余的按原样输出。

输入描述:
第一行包含要给整数n。1≤n≤100
接下来n行每行包含一个由小写英文字符构成的字符串，字符串长度不超过100。
输出描述:
按顺序输出处理后的每个单词。

输入
4
word
localization
internationalization
pneumonoultramicroscopicsilicovolcanoconiosis
输出
word
l10n
i18n
p43s


//string对象需要开始进行初始化，否则字符拼接无法成功，同时使用+=运算免去产生临时对象变量，所以后面需要进行倒置
#include <bits/stdc++.h>
using namespace std;

int main()
{
	int n;
	cin>>n;
	string* result=new string[n];
	for(int i=0;i<n;++i)
    {
        string temp;
        cin>>temp;
        if(temp.size()<10&&temp.size()>0)
        {
            result[i]=temp;
        }
        else
        {
            int Length=temp.size()-2;
            result[i]="";
            result[i]+=temp[Length+1];
            while(Length)
            {
                result[i]+=Length%10+'0';
                Length/=10;
            }
            result[i]+=temp[0];
            reverse(result[i].begin(),result[i].end());
        }
    }

    for(int i=0;i<n;++i)
    {
        cout<<result[i]<<endl;
    }
    delete[] result;

	return 0;
}


2、有限域
在抽象代数中，我们学过一个关于有限域的定理：存在一个大小为q的有限域当且仅当q是某个素数p的方幂，即q=pk.

输入描述:
第一行包含一个整数，数的范围在[1,10000]
输出描述:
输出阶数不超过

输入
1
输出
0

//题目没有看懂



3、舞会
今天，在冬木市举行了一场盛大的舞会。参加舞会的有n 位男士，从 1 到 n 编号；有 m 位女士，从 1 到 m 编号。对于每一位男士，他们心中都有
各自心仪的一些女士，在这次舞会中，他们希望能与每一位自己心仪的女士跳一次舞。同样的，对于每一位女士，她们心中也有各自心仪的一些男士，她
们也希望能与每一位自己心仪的男士跳一次舞。在舞会中，对于每一首舞曲，你可以选择一些男士和女士出来跳舞。但是显然的，一首舞曲中一位男士只
能和一位女士跳舞，一位女士也只能和一位男士跳舞。由于舞会的时间有限，现在你想知道你最少需要准备多少首舞曲，才能使所有人的心愿都得到满足？

输入描述:
第一行包含两个整数n,m，表示男士和女士的人数。1≤n,m≤ 1000
接下来n行，
第i行表示编号为i的男士有ki个心仪的女生
然后包含ki个不同的整数分别表示他心仪的女士的编号。
接下来m行，以相同的格式描述每一位女士心仪的男士。
输出描述:
一个整数，表示最少需要准备的舞曲数目。

示例1
输入
2 3
1 1
2 2 3
0
0
0
输出
2
示例2
输入
3 3
2 1 2
2 1 3
2 2 3
1 1
2 1 3
2 2 3
输出
2


//未考虑好
